**Задача 1.** Да се напише функция **generatePowers**, която по дадени
различни естествени числа **k**, **t** ≥ 2, генерира безкрайния поток от всички
числа от вида **k<sup>x</sup>t<sup>y</sup>**, без повторения и подредени в нарастващ ред.
```haskell
generatePowers 2 3 → [1, 2, 3, 4, 6, 8, 9, ... ]
```

**Задача 2.** Път от корен до възел в двоично дърво кодираме с поредица от
цифри 0 и 1, която започва с цифрата 1, а за всяка следваща цифра 0 означава
завиване по левия клон, а 1 — по десния. Да се реализира функция **countCodes**,
която в двоично дърво от числа намира броя на числата **x**, които съвпадат по
стойност с двоичното число, кодиращо пътя от корена до **x**.
Представянето на дървото е по ваш избор.
```scheme
(countCodes '(1 (2 () (3 () ()) (4 (6 () ()) ()))) → 3
```

**Задача 3.** Даден е списък от **n** списъци от числа **l<sub>1</sub>**, …, **l<sub>n</sub>** и
списък от **n** функции **f<sub>1</sub>, …, f<sub>n</sub>**. Да се реализира функция **aProg**,
която връща списък **x<sub>1</sub>, …, x<sub>n</sub>**, където **x<sub>i</sub> ∈
l<sub>i</sub>** и **f<sub>1</sub>(x<sub>1</sub>), f<sub>2</sub>(x<sub>2</sub>),
... f<sub>n</sub>(x<sub>n</sub>)** образуват аритметична прогресия. В случай, че
такива **x<sub>i</sub>** не съществуват, функцията да връща празния списък.
```haskell
aProg [[1,2], [3,4], [5,7]] [(+3), id, (7-)] → [1, 3, 5]
```

**Задача 4.** Лекарство се задава със наредена двойка от име (низ) и списък от
активни съставки, зададени като наредени двойки от име (низ) и количество в мг
(цяло число). Казваме, че лекарството **A** е по-силно от лекарството **B**, ако
**A** има всички активни съставки на **B** (евентуално и още други) в поне
същите количества, като поне една от съставките е в по-голямо количество.
Да се реализират функциите:
- **isStronger**, която по две дадени лекарства проверява
дали първото е по-силно от второто.
- **leastStrongest**, която по лекарство **A** и списък от лекарства **L** намира
името на лекарство **B**, което е по-силно от **A** и сумата от разликите в
количествата на активните съставки на **B** и **A** е възможно най-малка, или
празният низ, ако такова няма.
- **strongRelation**, която по списък от лекарства **L** връща списък от наредени
двойки от лекарство и списък от имена на лекарства в **L**, които са по-силни от
него.
```haskell
l = [("A",[("p",5),("q",3)]),("B",[("p",4),("q",3)]),("C",[("p",3)])]
isStronger (l!!0) (l!!1) → True
leastStrongest (l!!2) l → "B"
strongRelation l → [(("A",...),[]),(("B",...),["A"]),(("C",...),["A","B"])]
```
