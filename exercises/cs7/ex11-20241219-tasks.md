# Упражнение 11 - Алгебрични типове данни

[код от упражнението](ex11-20241219-solutions.hs)

### Зад.1.
Да се напишат следните функции за списъци (както и техните типови сигнатури). Целта е те да се възползват от `Maybe`, за да бъдат тотални функции и никога да не връщат `error`.
- `safeHead`
- `safeTail`
- `safeUncons`
- `stripPrefix`
- `findIndex`
- `maybeToList`
- `mapMaybe :: (a -> Maybe b) -> [a] -> [b]`

### Зад.2.
Да се напише функция `maxSumPath`, която приема за аргумент двоично дърво с числа във възлите и намира максималната сума на числата по някой път от корен до листо.

### Зад.3.
Да се напише функция `prune`, която по дадено двоично дърво `t` връща ново дърво `t'`, което представлява `t`, в което всички листа са премахнати.

### Зад.4.
Да се напише функция `bloom`, която по дадено двоично дърво `t` връща ново дърво `t'`, което представлява `t`, в което на всички листа са добавени по два наследника - нови листа. Стойността в тези нови листа да е същата като в оригиналното листо, от което са излезли.

### Зад.5.
Да се имплементират стандартните ротации на двоични дървета:
![Tree rotations](https://upload.wikimedia.org/wikipedia/commons/2/23/Tree_rotation.png)

### Зад.6.
Да се напише функция `treeМap`, която `map`-ва дадена функция `f` на всички стойности в дадено дърво (тук не е задължително стойностите в дървото да са числа).

### Зад.7*.
Да се дефинира тип дърво с произволен брой наследници на всеки възел и да се инстанцира класа от типове `Functor` за него.

### Зад.8.
Да се напише алгебричен тип данни `NonEmpty`, който символизира непразен списък. За него се напишат аналози на някои от най-често използваните функции за обикновени списъци (`head`, `tail`, `length`, `reverse`, `uncons`). Напишете и някои от често използваните функции от по-висок ред, като `map`,`filter`,`foldr`.

_Упътване:_ Ако конструкторът от глава и опашка на този списък е _оператор_, добавете му `infixr 5`, за да съвпада с `(:)`
