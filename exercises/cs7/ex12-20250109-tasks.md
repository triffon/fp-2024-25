# Упражнение 12 - Алгебрични типове данни

[код от упражнението](ex12-20250109-solutions.hs)

### Зад.1.
Да се имплементират стандартните ротации на двоични дървета:
![Tree rotations](https://upload.wikimedia.org/wikipedia/commons/2/23/Tree_rotation.png)

### Зад.2.
Да се напише функция `treeМap`, която `map`-ва дадена функция `f` на всички стойности в дадено дърво, но запазва структурата му (тук не е задължително стойностите в дървото да са числа).

### Зад.3*.
Да се дефинира тип дърво с произволен брой наследници на всеки възел и да се инстанцира класа от типове `Functor` за него.

### Зад.4.
Да се дефинира тип `BST`, който да представлява двоично наредено дърво, съдържащо стойности от произволен тип във възлите си. Да се дефинират следните функции към него:
- `bstInsert :: Ord a => a -> BST a -> BST a` - добавяне на стойност в дървото
- `bstSearch :: Ord a => a -> BST a -> Bool`  - търсене на стойност в дървото
- `bstValues :: BST a -> [a]`                 - получаване на списък със всички стойности в дървото
- `bstSize :: BST a -> Int`                   - брой стойности, съдържани в дървото
- `bstSort :: Ord a => [a] -> [a]`            - сортиране, използвайки `BST` като междинна структура

### Зад.5.
Да се дефинира тип `Map`, който да представлява структурата от данни асоциативен списък, реализирана с двоично наредено дърво. Да се дефинират следните функции към нея:
- `mapInsert :: Ord k => k -> v -> Map k v -> Map k v` -- вмъкване на ключ със стойност в дървото. Ако стойност за този ключ съществува, нека тя да бъде заместена с новата.
- `mapSearch :: Ord k => k -> Map k v -> Maybe v`      -- търсене на стойност по ключ в дървото (обърнете внимание на върнатия тип)

### Зад.6.
Да се инстанцира класа `Functor` и за гореспоменатия тип `Map`.

_Упътване:_ кои от данните в `Map` можем да променяме и кои не? Защо?

### Зад.7*.
Да се дефинира тип `Direction`, който да символизира посока при търсене в двоично наредено дърво (ляво или дясно). Да се дефинира функция `bstPath :: Ord a => a -> BST a => ???`, която по даден елемент и двоично наредено дърво намира пътека (последователност от посоки) до елемента в дървото.

_Упътване:_ какъв трябва да е типът на резултата?

### Зад.8.
Да се дефинира тип `Expr`, който да представлява математически израз - функция на един аргумент. Освен този аргумент, този израз може да съдържа само числа (`Double`), или следните операции: събиране, изваждане, умножение, деление или степенуване* на два израза. Да се дефинират следните функции към него:
- `eval :: Expr -> Double -> Double` -- изчислява стойността на функцията по дадена стойност на аргумента ѝ
- `derive :: Expr -> Expr`           -- изчислява производната на дадена функция - тя очевидно също е функция, която искаме да можем отново да диференцираме или оценяваме точно.

\* за улеснение ще позволяваме само повдигане на израз на степен число, както и число на степен израз. Това значи, че няма да можем да представяме функции като x<sup>x</sup>, (1+2)<sup>x</sup> или x<sup>(3+5)</sup>

### Зад.9*
Да се напише функция `treeAvg t`, която заменя стойностите във всеки възел на дадено дърво със средно-аритметичното на минималната и максималната стойност в поддървото с корен съответния възел. Може ли да се имплементира само с едно обхождане на дървото?

### Зад.10*.
Път от корен до възел в двоично дърво кодираме с поредица от цифри 0 и 1, която започва с цифрата 1, а за всяка следваща цифра 0 означава завиване по левия клон, а 1 — по десния. Да се напише функция `sameAsCode t`, която в двоично дърво от числа връща списък от тези числа `x`, за които стойността на двоичното число, кодиращо пътя от корена до възела на `x`, съвпада с `x`. Подредбата на числата в списъка няма значение.
