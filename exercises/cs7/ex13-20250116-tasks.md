# Упражнение 13 - Алгебрични типове данни, cont.

[код от упражнението](ex13-20250116-solutions.hs)

### Зад.1.
Да се дефинира тип `Expr`, който да представлява математически израз - функция на един аргумент. Освен този аргумент, този израз може да съдържа само числа (`Double`), или следните операции: събиране, изваждане, умножение, деление или степенуване* на два израза. Да се дефинират следните функции към него:
- `eval :: Expr -> Double -> Double` -- изчислява стойността на функцията по дадена стойност на аргумента ѝ
- `derive :: Expr -> Expr`           -- изчислява производната на дадена функция - тя очевидно също е функция, която искаме да можем отново да диференцираме или оценяваме точно.

\* за улеснение ще позволяваме само повдигане на израз на степен число, както и число на степен израз. Това значи, че няма да можем да представяме функции като x<sup>x</sup>, (1+2)<sup>x</sup> или x<sup>(3+5)</sup>

### Зад.2
Да се напише функция `labelTree :: Eq a => Tree a -> Tree Int`, която заменя всеки елемент в дадено дърво с неговата поредност на срещане при ляво-корен-дясно обхождане на дървото:
```
    ┌──'c'──┐         ┌──3──┐
 ┌─'a'─┐   'b'  ->  ┌─2─┐   1
'b'   'a'           1   2

t :: Tree Char
t = Node 'c' (Node 'a' (Node 'b' Empty Empty)
                       (Node 'a' Empty Empty))
             (Node 'b' Empty Empty)
```
_Упътване:_ тук резултатът от обхождането е `['b', 'a', 'a', 'c', 'b']`, следователно `'b'` е срещнат първи, след това `'a'`, след това `'c'`.

### Зад.2**.
Горната функция да се имплементира само с едно обхождане на даденото дърво.
